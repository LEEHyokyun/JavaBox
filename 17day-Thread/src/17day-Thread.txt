ㅁ Thread
	ㅁ Thread 개념
		* 실, 실이 여러개 모여 옷감을 만들듯이 하나의 실행단계로 표현되어 프로세스내 실행단위로 표현하는 개념
			ㄴ 세부적 실행 단위, 한 프로세스는 여러 스레드가 실행되면서 구성되는 것이다.
			ㄴ 이때 프로세스란, 현재 실행 중인 프로그램을 일컫는다.
		* 즉, 하나의 프로세스는 여러 스레드로 이루어져 있다.
			ㄴ 동영상 플레이어 프로세는, 영상/자막/음악 등의 여러 스레드로 구성되어있다.
			ㄴ 이러한 스레드들이 동시에 실행되는 것을 멀티 스레딩이라 한다.
			ㄴ internet - client별 thread 생성!
		* 지금까지 thread 이용하긴 하였으나, main thread만 이용하였다.
			ㄴ 별도의 thread를 구성 및 start하여 멀티스레드 구조(개별적 실행) 구성!
		
	ㅁ Thread 생성방법
		* extends Thread(java.lang.thread)
		* implements Runnable (※ 권장, 다중구현이 가능하기 때문에 계층구조 생성 가능)
			ㄴ thread 구현체 생성후, 해당 구현체를 Thread 객체의 생성자로 구성
			ㄴ 다중 구현방식이 가능하여, 다중 계층구조 및 별도 클래스 상속이 가능하다.
			ㄴ OOP 구조에 더 가까운 방식이기도 하다.
						
	ㅁ Thread 동작원리 : start(), run()
		* JVM이 가상의 CPU, 스케쥴러 역할을 하여 스레드의 상태를 제어한다.
		* 스레드의 실행(start()), 종료(run())은 프로그래머가 설정 및 호출한다.
		* 내부적인 스레드의 실행내용(run())은 개발자가 별도 정의(오버라이드)해주며, 이 스레드 실행은 JVM에 의해 호출되어 실행된다.
		* 기본적으로 CPU의 개수는 제한적, 번갈아가면서 동작하거나 멀티 스레딩을 동작시킨다.
			ㄴ 참고로 server 등 구축 시 멀티스레드가 반드시 필요하다.
		ㅁ start() : 스레드를 "실행가능한 상태로" 상태변화시킨다.
			* 이후 JVM에 의해 스케쥴링되어, run()으로 정의된 내용을 실행하게 되어 Running 상태로 됨.
		ㅁ run() : 스레드의 실행내용을 정의한다.
			* 즉, JVM에 의해 running 상태로 되었다면 해당 내용을 실행하게 된다.
			* run() 메소드 실행이 종료된다면, 해당 스레드는 종료된다.
			
	ㅁ Multi Threading
		ㄴ example : 
		VideoWorker worker1 = new VideoWorker();
		Thread thread1 = new Thread(worker1);
		thread1.start();
		AudioWorker worker2 = new AudioWorker();
		Thread thread2 = new Thread(worker2);
		thread2.start();
		* 출력시 뒤죽박죽 출력, 즉 각각의 스레드들이 멀티로 개별적으로 동작
		* 사용자 입장에서는 동시에 실행되는 것처럼 보인다.
		* 이것이 멀티스레드의 기본 원리이자 동작방식임에 유의.
			ㄴ sleep을 활용할 경우, 스케쥴러에 의한 스레드 유사동시적인 실행이 용이해지는 경향을 보임.
		* 하위 클래스에 대한 다수의 스레드가 생성될 경우
 		* 스케쥴러에 의해 run() 메소드가 여러번 호출되지만
 		* 스레드별로 stack 메모리에 생성되어, 각 stack 메모리 영역에서 정보가 생성 및 저장된다.
 		* 이렇기때문에 각각 생성된 스레드별로 0,0,0 반복인자(i)(=지역변수)가 생성되며 동시에 누적되어 저장된다.
 		* 각 스레드가 생성된다면 독자적인 stack 메모리를 할당하고 변수도 여기에 저장된다.
 		
 	ㅁ Thread는 보통 우선순위방식을 채택한다.
		ㅁ 즉, 우선순위가 높을수록 스케쥴러가 해당 스레드를 실행할 확률이 높다.
		ㅁ 우선순위는 가장 낮은 1부터 10까지 존재하며, 운영체제별로 우선순위가 적용되는 여부는 다르다.
		* gc는 우선순위가 낮다.
		
 	ㅁ backup Thread(Daemon Thread)
 		ㅁ word(부모 스레드)에서 backup thread를 실행전에 setDaemon(true) 한다.
 			ㄴ 자신을 호출한 부모 스레드가 종료되면, 해당 백업 스레드도 자동 종료된다.
 		* 해당 backup thread는 물론, 부모 스레드와 개별적으로 stack에 적재되어 자신의 동작을 실행(=백업, 자동저장)
 		* word 등과 같은 프로세스가 실행되면 같이 실행된다.
 		* 독립적으로 1분마다 한번씩 자동저장이 실행, 부모 프로세스가 종료되면 같이 종료되는 형식의 스레드.
 			ㄴ backup thread 내부적으로는 백업 기능이 while(true)..즉, 지속 실행되도록 구성한다.
 		* 최종적으로 word(부모) 스레드 종료시, Bthread.backup을 강제적으로 명기하여 1번더 저장되도록 구성.
 	
 	ㅁ 멀티스레드 환경
 		ㅁ 수행하는 작업의 단위나 규모가 다소 클 경우, 규모가 있는 경우 스레드를 2개 이상 만든 환경에서 동작을 실행한다.
 		ㅁ 각 스레드는 구현체 방식으로 구현
 		
※ Thread.sleep(time)
	* 해당 시간동안 스레드의 실행을 잠시 멈추고 다시 실행한다. 
	
※ 채팅창 자체도 단일 스레드 구성으로는 절대 실행이 불가능한 환경이다.
	* output thread, input thread 등이 동시적으로 실행되어야 구성이 가능!
	* 즉 입력스레드, 출력스레드가 run 되면서 동시적으로 동작(하는 것처럼 보이는 것)
	
	
	ㅁ synchronized(동기화 처리)
	